<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Algorithmsinpython by nasirkZai</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Algorithmsinpython</h1>
      <h2 class="project-tagline">Searching algorithm, Finding log or series and Tree data structure implementation python </h2>
      <a href="https://github.com/nasirkZai/AlgorithmsInPython" class="btn">View on GitHub</a>
      <a href="https://github.com/nasirkZai/AlgorithmsInPython/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/nasirkZai/AlgorithmsInPython/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="algorithmsinpython" class="anchor" href="#algorithmsinpython" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AlgorithmsInPython</h1>

<p>This repo contain Searching algorithms python with sorting using values and pointer, tree data structure ,Log algorithms,Finding series in given number of list and Interfaces implementation.</p>

<h3>
<a id="algorithm" class="anchor" href="#algorithm" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Algorithm</h3>

<h6>
<a id="definition" class="anchor" href="#definition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DEFINITION</h6>

<p>An algorithm is a sequence of unambiguous instructions for solving a problem.</p>

<h3>
<a id="selection-sort" class="anchor" href="#selection-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Selection sort</h3>

<p>A sorting technique that is typically used for sequencing small lists. It starts by comparing the entire list for the lowest item and moves it to the #1 position. It then compares the rest of the list for the next-lowest item and places it in the #2 position and so on until all items are in the required order. Selection sorts perform numerous comparisons, but fewer data movements than other methods input values.<br>
<strong>Time Complexity</strong> Best    Average O(n<sup>2</sup>)    Bubble Sort O(n<sup>2</sup>)</p>

<h3>
<a id="bubble-sort" class="anchor" href="#bubble-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bubble sort</h3>

<p>Sometimes referred to as sinking sort, is a simple sorting algorithm that works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items and swapping them if they are in the wrong order.<br>
<strong>Time Complexity</strong> Best    Average O(n)    Bubble Sort O(n<sup>2</sup>)</p>

<h3>
<a id="insertion-sort" class="anchor" href="#insertion-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Insertion sort</h3>

<p>A sorting algorithm that inserts each item in the proper place into an initially empty list by comparing it with each item in the list until it finds the new element's successor or the end of the list. <br>
<strong>Time Complexity</strong> Best    Average O(n)    Bubble Sort O(n<sup>2</sup>)</p>

<h3>
<a id="merge-sort" class="anchor" href="#merge-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Merge sort</h3>

<p>A sorting technique that sequences data by continuously merging items in the list. Every single item in the original unordered list is merged with another, creating groups of two. Every two-item group is merged, creating groups of four and so on until there is one ordered list.<br>
<strong>Time Complexity</strong> Best    Average  O(n log(n))     Bubble Sort        O(n log(n))</p>

<h3>
<a id="quick-sort" class="anchor" href="#quick-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Quick sort</h3>

<p>A sorting technique that sequences a list by continuously dividing the list into two parts and moving the lower items to one side and the higher items to the other. It starts by picking one item in the entire list to serve as a pivot point. The pivot could be the first item or a randomly chosen one. All items that compare lower than the pivot are moved to the left of the pivot; all equal or higher items are moved to the right. It then picks a pivot for the left side and moves those items to left and right of the pivot and continues the pivot picking and dividing until there is only one item left in the group. It then proceeds to the right side and performs the same operation again. <br>
<strong>Time Complexity</strong> Best    Average  O(n log(n))     Bubble Sort        O(n log(n))</p>

<h3>
<a id="heap-sort" class="anchor" href="#heap-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Heap sort</h3>

<p>A sorting algorithm that works by first organizing the data to be sorted into a special type of binary tree called a heap. The heap itself has, by definition, the largest value at the top of the tree, so the heap sort algorithm must also reverse the order input values.</p>

<h3>
<a id="tree-data-structure" class="anchor" href="#tree-data-structure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tree data structure</h3>

<p>A tree is a widely used abstract data type (ADT) or data structure implementing this ADT that simulates a hierarchical tree structure, with a root value and subtrees of children, represented as a set of linked nodes.<br>
<strong>Insertion Complexity:</strong>   worst case O(logn), average best case O(logn)<br>
<strong>Searching Complexity:</strong>   worst case O(logn), average best case O(logn)<br>
<strong>Deletion Complexity:</strong>    worst case O(logn), average best case O(logn)<br>
<strong>Sorting Complexity:</strong>  O(nlogn)</p>

<h3>
<a id="avl-tree" class="anchor" href="#avl-tree" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AVL tree</h3>

<p>An AVL tree is another balanced binary search tree. Named after their inventors, Adelson-Velskii and Landis, they were the first dynamically balanced trees to be proposed. Like red-black trees, they are not perfectly balanced, but pairs of sub-trees differ in height by at most **1**, maintaining an **O(logn)** search time. Addition and deletion operations also take O(logn) time.</p>

<h5>
<a id="definition-of-an-avl-tree" class="anchor" href="#definition-of-an-avl-tree" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Definition of an AVL tree</h5>

<p>An AVL tree is a binary search tree which has the following properties:<br></p>

<ol>
<li>The sub-trees of every node differ in height by at most one.</li>
<li>Every sub-tree is an AVL tree.</li>
</ol>

<p><strong>Search Complexity:</strong>  worst case O(logn), average best case O(logn)<br>
<strong>Insert Complexity:</strong> worst case O(logn), average best case O(logn)<br>
<strong>Delete Complexity:</strong>  worst case O(logn), average best case O(logn)<br></p>

<h3>
<a id="red-black-tree" class="anchor" href="#red-black-tree" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Red Black tree</h3>

<p>A red–black tree is a kind of self-balancing binary search tree. Each node of the binary tree has an extra bit, and that bit is often interpreted as the color (red or black) of the node. These color bits are used to ensure the tree remains approximately balanced during insertions and deletions.</p>

<h4>
<a id="properties" class="anchor" href="#properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Properties</h4>

<ol>
<li>A node is either red or black.</li>
<li>The root is black. This rule is sometimes omitted. Since the root can always be changed from red to black, but not necessarily vice versa, this rule has little effect on analysis.</li>
<li>All leaves (NIL) are black.</li>
<li>If a node is red, then both its children are black.</li>
<li>Every path from a given node to any of its descendant NIL nodes contains the same number of black nodes. Some definitions: the number of black nodes from the root to a node is the node's black depth; the uniform number of black nodes in all paths from root to the leaves is called the black-height of the red–black tree.</li>
</ol>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/nasirkZai/AlgorithmsInPython">Algorithmsinpython</a> is maintained by <a href="https://github.com/nasirkZai">nasirkZai</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
